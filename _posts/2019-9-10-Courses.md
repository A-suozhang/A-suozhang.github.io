---
layout:     post                    # 使用的布局（不需要改）
title:      大四上的课程              # 标题 
subtitle:   本科期间最后几节课了，混！        #副标题
date:       2019-10-19              # 时间
author:     tianchen                      # 作者
header-img:  img/bg-dayun0.jpg  #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
---


# 无线电导航与原理 （周一56）
* 黄志刚    
* 开卷，点名
    * 5考勤 + 15作业 + 80考试

--- 
 
# 通信网络原理与技术 （周二56）
* 熊庆旭
##作业题 
* 2.2 2.7 4.4 4.6 4.10 4.11 6.9 6.10 7.9 7.10 编程：C语言实现Prim（按照教材6.7）矩阵形式给出运算结果
    * 发送到 bh041124@sohu.com

## 考核
* 平时20 网络仿真10 专题讨论10 课程参与10 考试50

### 引言/概述
1. 通信网络组成 - *节点*之间依照一定*协议*完成信息交互
    * 节点（点 - 终端，交换，转发）+链路（link the node）
        * 终端： 1. 信号转化（用户信息 - 传输的信号） 2. 传输匹配（传输信号与传输链路的匹配） 3. etc：信号的产生识别监控管理
    * 协议
    * 能够完成*任意*节点的信息交换
        * 从一点到另一点单向传输：是广播，不是单工
2. 实际组成部分
    * 终端设备：实际指的是接口
    * 业务节点：完成业务的
    * 传输系统: 传输链路
    * 交换设备： 用户信息的几种，转发，或终端或设别之间一对一，一对多的信息交换
* ATM交换机，复杂，贵
3. 网络体系结构
* 层次化： 各层隔离，上层调用下层的服务，不关心如何实现
* 隔离化： 同层次分为多个并行的实现模块
* 协议： 约定,规则 （干什么怎么做）
    * 实体：执行协议的硬/软件进程
    * 分段与分装:
        * sdu 服务数据单元来自上一层
        * pci 版本控制信息，对等实体之间的控制信息
        * pdu 协议数据单元，对等实体之间的信息单元 （pdu = pci+sdu）
        * ICI：地址，差错校验，流量、差错控制 
    * 协议能做啥
        * 差错控制 - 抗误码保护，比如纠正误码，要求重发
        * 流量控制 - 数据速率进行控制  
        * 连接控制
            * 连接： 两个通信实体之间建立一种逻辑关系 （预约了通信计算存储资源）
            * 面向连接 TCP（通信之前需要建立连接关系） UDP（两个实体之间不建立连接关系）
        * 寻址：
            * 不同层之间有着对应的身份标识
                * MAC - 数据链路； IP - 网络层； port - 应用层
            * 可以用于复用
        > 网络很重要的是**平衡**，显著提高某一链路的数据速率会导致整体速率变慢
        * 接入控制： 分析新的接入点的服务需求，寻找是否能够满足，否则拒绝（Call/Connection Admission Control）
    * 需要解决的几大问题
        * 连通性： 建立可靠的物理链路 （主要在物理和数据链路层）
        * 寻址（路由）：建立有效的信息传输路径
        * 服务质量(传输控制)
4. 评价指标
    * 服务指标(主观)
    * 性能指标(客观)
        * 容量
        * 吞吐量 bps
        * 端到端时延
        * 丢包
        * 抖动


### 排队论
* 运筹学的一个分支
1. 标准系统模型
    * 输入过程(一个随机过程)，表示了顾客源，以下是3种描述方式
        * M(t) 表示时间间隔内到达的顾客总数
        * {sn} 表示第n个顾客的到达时间1
        * {Tn} 表示第n个顾客与之前顾客的时间间隔
        * *Example* Poisson分布的泊松流，到达顾客总数服从负指数分布V
            * $$ \lambda $$ 指单位时间到达顾客数的平均数值 $$ E(T)=\frac{1}{\lambda} \quad  D(T)=\frac{1}{\lambda^2} $$
        * N个统计独立的泊松过程叠加 - N阶爱尔兰分布
            * (当K->$$ \infty $$,概率密度函数变成冲激)
    * 排队规则
        * 损失制（也就是队列容量不是无穷大）： 顾客不排队直接跑
            * *会导致等待时间随着等待的人数有一个分段*
        * 等待制： 先到先服务，后到先服务，随机服务，优先级服务
    * 服务机制
        * 分单/阶段
2. 评价指标
        * 等待时间 （到开始接受服务）
        * 逗留时间 （从到达到离开）
        * 系统队长 （正在排队的顾客数目）
        * 排队效率  平均服务窗口占用率、
3. 描绘输入过程的主要分布
    * Poisson (无记忆，平稳，稀疏)
        * 在某个时间区间内有k个顾客到达的*概率*
        * 常数 表示了*泊松流的强度*或者是*到达率*
    * 负指数分布 *当顾客服从泊松流的时候，到达时间间隔T服从负指数分布*
    * 爱尔兰(Erlang)分布，*k个互相独立的变量T都服从负指数分布*
        * k=1的时候相当于负指数
        * k=无穷时候相当于一个单位脉冲
4. 符号表示
    * M/M/m/n 顾客到达时间-服务时间(都服从负指数分布-对应着顾客是泊松流)-有m个服务窗口-系统容量为n
        * 这种分布是马尔科夫的，无后效性
        * 有lambda，miu两个*转移强度*，分别代表“生”与“灭”的概率
        * 古典解析-瞬态分析/现代方法-状态流图
        * 当m=n和n=无穷的两种特殊情况
    * M/G/1
        * 另外一种经常分析的模型，不是Markov的
5. Little模型 $$ L=\lambda*W $$
    * W代表逗留时间，$$\lambda$$单位时间到达的客户
    * 系统内部的顾客数目=顾客到达率*平均每个顾客的逗留时间

### 通信网络建模
1. 描述发生的随机事件：将*发生的时间间隔*看做一个变量
    * 1/m(均值)就是发生的*事件强度* - 衡量负载
    * 方差系数 - 衡量抖动
    * 歪度系数 - 衡量对称性
    * 自相关系数 - 衡量事件的相关性
2. 实际的业务模型
    * Markov(用于理论分析)
        * 更新过程(Renewal Process) - Poisson的推广，发生的间隔是独立同分布的，但是分布的函数不是无记忆的指数分布
        * IPP间断泊松过称(Poisson Process通过一个随机开关)
            * 描绘了溢出，又保存了更新过程的特性
            * *分组交换网中的数据到达过程可以用IPP来近似*
        * SPP(交互泊松) 一个正常PP+IPP
        * 开关过程 ON/OFF均为负指数分布
            * 还属于更新过程
                * 可以用IPP模型来近似
            * 用于ATM模型的建模
    * 自回归(AR) (用于计算机仿真)
3. 可能用到的几种概率分布
    * 连续
        * 均匀
        * 正态
        * 瑞利 - 两个独立正交的正态分布的二维分布
        * 负指数 - *无记忆，无后效*
            * 经常拿来近似寿命
        * k阶Erlang分布
            * k个随机变量都符合负指数，其求和服从xx
            * 如果这k个是加权和，就是*超指数分布*
    * 离散
        * 0-1分布
        * 二项
        * 几何分布 - 描述了无穷伯努利实验中，事件首次发生需要的次数
        * 泊松分布
4. 业务源的建模
    1. 纯随机事件
        * 事件之间独立/事件发生的间隔无记忆性 - *负指数分布描述*
    2. 平缓随机事件
        * 方差<1，用k阶爱尔兰分布描述
        * 常用于多级系统的建模
        * 为了简便常简化为Poisson
    3. 突发事件
        * IPP来描绘
5. 实际通信网络的建模 (*模型对应到实际*)
    * MMmn系统对应着电话网络系统-*电路交换网*(因为电话会占线，所以需要排队)
    * 数据通信网  
        * 数据的基本单位是"包"，有时候也叫做“分组”（因而整个网络也称为*分组交换网*）
        * 多个分组(包)同时到达中转节点(也就是交换机)
        * (当多个分组需要往同一个目标地址输出链路上发包的时候，就需要排队)
    * ATM网络建模
        * 多了一环*给用户一次申请流量特性而按需分配* 
        * CBR/VBR业务源
    * 移动通信网（WCDMA）的建模

### 通信网络的传输和交换
1. 传输链路 （除了最直接的光/电通路之外还包括了发射/接受转换设备等）
    * 双绞线，同轴电缆，光纤
    * **复用**：传输链路的带宽(容量)远远大于需要传输信号的带宽，因而有*复用*
        * 频分复用
        * 时分复用
            * 先给多个媒介轮流获得使用权（是时帧）又再一次划分为更小的单位（叫时隙）
            * 同步或者是异步 （S/ATDM）
            * 同步固定帧长，异步按需分配
    * **纠错**
        * 前向纠错 FEC - 发射的时候增加冗余度
            * 需要进行纠错编码(属于信源编码)
            * 可分为分组码或者卷积码
            * *避免重传的开销大*
        * 自动重传请求 ARQ - 当接受端不能正确解调的时候通知发射端重新发送
            * 发生在数据链路以及传输层
            * 发射端加上*检错码*（注意不能够纠错）
            * 奇偶校验，循环冗余校验CRC
            * *需要一条反馈信道*
            * 分为1. 停等 2， 后退N步 3， 选择重发
        * 混合自动重传
2. 交换技术 - 为了实现通信网中的任意两个终端之间的点对点通信 
    * 不可能使用全联通的结构，而是在中间添加中继节点
        * *为提高链路的利用率*
    * 电路交换CS
        * 双方暂时建立一条专用的物理链路
        * 空分（有一个交换矩阵）与时分（用于STDM，使用一个TSI-时隙交换器，核心部件是一个RAM）
        * *不适用于突发性强*
    * 分组交换PS，包交换
        * 数据包分组交换，比如IP/UDP协议
            * 还有一种叫做虚电路转发
        * *1.传输链路的利用率高 2.不同类型的终端之间可以使用 3.有优先级 4.可靠性高*
        * *1.时延大，抖动大*
    * 快速分组交换
        * 帧中继-用于光纤，在物理层几乎不错，因而可以快速交换
        * ATM-异步传输模式
    * 软交换  

### 多址接入协议 
* 多个用户共通使用*同一个物理信道*的信道接入原则,让多个信号在某一维度上*正交*，这样才能互不影响地解调出来(T/F/CDMA)
* 在OSI上的数据链路层
* 静态分配方案-传统的T/F/CDMA (DMA-Division Multiple Access)
    * OFDM/GSM(T/FDMA)
    * CDMA用不同的码型-需要一个*扩频序列*（m序列...）
    * *每个用户单独享用某一个子信道的使用权，不需要额外的控制*但是无法应对突发性业务
* 动态的分配方案
    * 随机-竞争访问
        * 相比于调度没有中央控制器，完全分布式控制
        * *是利用了随机性来规避冲突*当业务负载高的时候*冲突概率高-吞吐量低-传输时延大*
        * 分为 *ALOHA(不使用信道忙信息)*或者是*载波侦听*
            * 后者在传输时延小的场景（无限局域网）
            * 纯P-ALOHA-用户直接把包往信道上面塞，如果没冲突就传输成功了，不成就经过一个随机事件之后再发（很脑瘫的一种方式）
            * 时隙S-ALOHA（为了减少信道上的冲突）-只有在时隙为整数的时刻才能发数据，会对齐延迟到整点来发
                * 性能提升了，但是复杂度也提升了
            * CSMA(Carrier Sense Multiple Access)-载波侦听多址接入-先听后说，减小了盲目性
                * 坚持：一直听
                * 非坚持：等待一个随机长度
                * 概率p坚持箭头
                * 带冲突检测（CD）发的同时收，检测冲突
                * 回避冲突（CA）- 使用一个RTS/CTS的握手
    * 调度-显式的控制
        * *控制开销过大*
        * 按需分配
            * 集中/分布式（*令牌环网*）
        * IEEE协议的点协调方案
    * 混合
        * 显示预约动态接入
            * 竞争申请+无竞争数据传输
        * 隐示预约动态接入

    

        

### 实验作业，实现一个Prim算法
* 用的C++，因为还有点菜，算法的实现过程还是有点Dirty
    * 少量参考了一些[算法图解的博客](https://blog.csdn.net/jnu_simba/article/details/8869876)，但是写法和他们不大一样
    * 讲道理这里应该贴个git链接的，但是我的workspace的repo是private...而且只有一个文件，所以：

``` c++

# include <iostream>

# define LENGTH(a)(sizeof(a)/sizeof(a[0])) // Interesting Way

using namespace std;

typedef char Vertex;


// Define The Graph Here
// I Know It's quite stupid
# define NumVertex 5
Vertex _Vex[NumVertex] = {'0','1','2','3','4'};
int _AdjacentMatrix[NumVertex][NumVertex] = {{0, 7, 5, 0, 20},
                                            {7, 0, 10, 15, 16},
                                            {5, 10, 0, 0, 30},
                                            {0, 15, 0, 0, 4},
                                            {20,16, 30, 4, 0}};


class Graph{
    public:
        Vertex Vexs[NumVertex]; // Adtually It's useless since we only call it by index, you can name it as you like
        int AdjacentMatrix[NumVertex][NumVertex];
        Graph();
        ~Graph();    
        void initializeGraph();
        void PrintGraph();
        void MST_Prim();
};

/*  并不支持构造函数直接给数组赋值
Graph::Graph(Vertex _Vex[], int** _AdjacentMatrix){
    Vexs =_Vex;
    AdjacentMatrix = _AdjacentMatrix;
}
*/

Graph::Graph(){
    cout << "Graph Created." << endl;
}

Graph::~Graph(){
    cout << "Graph Deleted" << endl;
}

void Graph::initializeGraph(){
    // 传一个二维数组作为形参实在有点麻烦
    // memcpy(_Vex,this->Vexs,sizeof(Vexs));
    // memcpy(_AdjacentMatrix,this->AdjacentMatrix,sizeof(AdjacentMatrix));

    // Here Comes Some Dirty Code
    for (int i=0;i<NumVertex;i++){
        this->Vexs[i] = _Vex[i];
    }
    
    for (int i=0;i<NumVertex;i++){
        for(int j=0;j<NumVertex;j++){
            this->AdjacentMatrix[i][j] = _AdjacentMatrix[i][j];
        }
    }

    cout << "Graph Initialized." << endl;
}

void Graph::PrintGraph(){
    cout << "The Vertexs Are:";
    for(int i=0;i<NumVertex;i++){
        cout << this->Vexs[i] << ',';
    }
    cout << endl;

    cout << "The Adjacent Matrix:" << endl;
    for (int i=0;i<NumVertex;i++){
        for (int j=0;j<NumVertex;j++){
            cout << this-> AdjacentMatrix[i][j] << " ";
        }
        cout << endl;
    }
}

// The Miniest Span Tree Prim Algo
void Graph::MST_Prim(){

    int NumVertexSelected = 0;
    int SelecetedVertex[NumVertex] ={0};

    SelecetedVertex[0] = 1; //Choose The 0th Vertex As Starting Point
    int x;
    int y;

    cout << "Edge" << " : " << "Weight" << endl;
    while(NumVertexSelected < NumVertex-1){
        int min = 65536; // Initialize Min As A Big Value
        x = 0;  // Being The Temp Min Edge's x&y index
        y = 0;

        for(int i=0;i<NumVertex;i++){
            if(SelecetedVertex[i]){     // Selected Vertex In Tree, Finding The Min Edge Linked with Them  
                for (int j=0;j<NumVertex;j++){
                    // if the node haven't been Selected && Is A Edge(diagonal elemnet of Adjacent Matrix are Zero)
                    // Also We Use 0 when no link,so we must exclude it
                    if (!SelecetedVertex[j] && this->AdjacentMatrix[i][j]){
                        if (min > this->AdjacentMatrix[i][j]){  // If A New Min Occurs
                            min = this->AdjacentMatrix[i][j];
                            x = i;
                            y = j;
                        }
                    } 
                }
            }
        }
        cout << x << "-" << y << ":" << this->AdjacentMatrix[x][y] << endl;
        SelecetedVertex[y] = 1;     // Y Node Has Been Chosen
        NumVertexSelected = NumVertexSelected+1;
    }

}


int main(){
    Graph g0;
    g0.initializeGraph();
    g0.PrintGraph();
    g0.MST_Prim();

    return 0;

}

```

* 简单解释一下
    * 没有任何优化，直接一个大循环
    * 维护了一个已经在树里的Vertex的数组
    * 对其中的Vertex所链接的所有边（除去可能会成环的（也就是又和上面集合中的Vertex相连））以及不是边的（因为严格来说adjacent matrix内部用0来表示没有链接上，会对取min带来麻烦）
    * 把每一轮循环找出来的最小边打印，并且将相连的Vertex加入集合
    * 测试用的图
        * ![](https://github.com/A-suozhang/MyPicBed/raw/master/img/20191019161738.png)
    * 结果如下
        * ![](https://github.com/A-suozhang/MyPicBed/raw/master/img/20191019161611.png)

---

# 遥测遥控 （周三34）
* 修春娣
* 40平时(有随堂题目) + 60开卷 

## 遥测技术
1. Telemetry (Tele-Remote;Metry-Measure) 遥测
2. *测控*信息：对精度可靠性要求高

--- 

# 软件无线电基础
* 万国龙
* 13718964928 F1110

