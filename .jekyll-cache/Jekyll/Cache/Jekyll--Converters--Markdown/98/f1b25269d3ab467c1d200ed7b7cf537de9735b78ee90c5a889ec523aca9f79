I"3%<h1 id="计算机网络">计算机网络</h1>
<ul>
  <li>一些关于计算机网络的简单笔记</li>
  <li>由于自己没有学过相关课程全靠自己理解</li>
</ul>

<h2 id="一些定义">一些定义</h2>
<ul>
  <li>C/S 模式（Client/Server）   B/S (Browser/Server)</li>
  <li>URL(Uniform Resource Locator) 统一资源定位符</li>
  <li>子网掩码： 真实IP是IP AND 上子网掩码
    <ul>
      <li>目的是将网络地址和主机地址两部分</li>
      <li>255.255.255.0 相当于把后8位去掉，局域网大小小于256个设备</li>
    </ul>
  </li>
</ul>

<h2 id="osi分层">OSI分层</h2>
<ul>
  <li>参考OSI的模型可以更好的理解一些概念</li>
  <li>分层更加分离，更加透明，在每一个层面都可以建立标准
    <ul>
      <li>对于这个层次，我们并不需要知道下一个层次是怎么work的，只要接受下一层的数据就可以
        <ul>
          <li>（HTTP并不需要知道是IPv4还是v6，只需要传过来的数据满足HTTP协议即可）</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>物理层</td>
      <td>网线</td>
    </tr>
    <tr>
      <td>数据链路层</td>
      <td>网卡</td>
    </tr>
    <tr>
      <td>网络层</td>
      <td>路由器（IP，ICMP）</td>
    </tr>
    <tr>
      <td>应用层</td>
      <td>HTTP、FTP、SMTP、TELNET</td>
    </tr>
    <tr>
      <td>↕接口</td>
      <td>Socket</td>
    </tr>
    <tr>
      <td>传输层</td>
      <td>TCP UDP（DCCP）</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>路由器对应的协议有比如 IP，ICMP等
    <ul>
      <li>P是protocol，所以IP协议其实是重复叫法，放在高考语文是病句</li>
    </ul>
  </li>
</ul>

<h2 id="socket">Socket</h2>
<ul>
  <li>Socket被翻译为“套接字”（很台湾风味的一个翻译），是应用层与传输层之间的一个管道
    <ul>
      <li>看做是一个应用进程
        <ul>
          <li>因为传输层以下一般都是操作系统来控制的</li>
          <li>而应用层协议一般通过应用进程来控制</li>
          <li>这个接口是一个API，建立应用程序与底层协议的Bridge</li>
        </ul>
      </li>
      <li>面向Socket编程</li>
      <li>标识为 IP：port
        <ul>
          <li>端口号自动配置或者手动指定</li>
          <li>80端口为Web Server（比如Nginx）的默认端口</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>传输层
    <ul>
      <li>应用程序之间的逻辑通信</li>
      <li>多路复用
        <ul>
          <li>和物理层的多路复用（TDM，FDM）不太一样</li>
          <li>本质是多个数据报文的同时接受与发送：
            <ul>
              <li>对每个数据包都做单独的处理
                <h2 id="udp--tcp">UDP &amp; TCP</h2>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>UDP
    <ul>
      <li>对IP协议的一个很简单的拓展
        <ul>
          <li>接受从网络层过来的数据，区分一下PORT号就丢给进程了（可以做差错检测，也可以不做）</li>
          <li>简单，高度可定制（在应用层定制）</li>
        </ul>
      </li>
      <li>相对TCP来说不用建立和维护连接，直接传</li>
      <li>数据帧中头部占的成分较小</li>
      <li>应用层可以控制发送时间和数据（可以完成复杂动作）</li>
      <li>UDP不提供重传！</li>
    </ul>
  </li>
  <li>TCP
    <ul>
      <li>一个出色的，面向连接的，PORT2PORT的协议</li>
      <li>按序字节流协议（好难理解）</li>
      <li>接收端和发送端都会存储一定的数据，用于重传和重组</li>
      <li>3次握手，4次挥手
        <ul>
          <li>3次握手： （建立连接）
            <ul>
              <li>某一端 发出 建立连接的请求
                <ul>
                  <li>同时会初始化序列号 X</li>
                </ul>
              </li>
              <li>另外一端 同意建立连接请求，并且返回一个报文：
                <ul>
                  <li>SYN=1 ACK=1</li>
                  <li>确认报文是X+1</li>
                </ul>
              </li>
              <li>收到确认建立请求报文，再返回一个确认报文
                <ul>
                  <li>ACK=1</li>
                  <li>确认报文序列号为Y+1</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>WHY Not 两次握手
            <ul>
              <li>防止，A发出请求建立连接的一个数据包很久都没有发过去，又发送了一次建立连接请求，这个时候，B收到了之前的那个请求，并且ack了，这时候A收到的B的请求实际上是回应第一次发出的请求，而不是第二次的，这样就混乱了。</li>
            </ul>
          </li>
          <li>4次挥手： （断开连接）
            <ul>
              <li>A准备断开连接，发送FIN=1，ACK=1</li>
              <li>B收到了FIN报文，回复一个确认报文（此时仍然可以正常传输数据（可以把之前没有传完的数据接着传））</li>
              <li>当B把需要传完的数据都传好了，再给A发送一个FIN报文</li>
              <li>A收到FIN报文，并且返回一个确认</li>
              <li>当B收到A的确认报文之后就可以断开连接了，但是A不行（如果A发出的确认报文在路上丢失了，那么B将会重发FIN报文，这样就会卡死）所以A要在一段时间（一般是2*数据报文的最大存活时间之后）没有收到FIN，也可以断开连接</li>
            </ul>
          </li>
          <li>之所以要4次挥手是因为TCP是全双工的</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>网路层
    <ul>
      <li>核心任务： 转发与路由（Route）</li>
      <li>需要知道数据去哪儿？</li>
      <li>包含了比如IP协议，ICMP协议等</li>
      <li>传输层来的TCP/UDP的数据包，需要在网络层添加一个头部，共通组成了IP数据报，然后交给数据链路层
        <ul>
          <li>包含了转发的目标（IP）地址
            <h2 id="ip">IP</h2>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>IP
    <ul>
      <li>长度32bit</li>
      <li>划分开成子网</li>
      <li>由网络号（位数不确定，大子网位数小）+主机号组成
        <ul>
          <li>现在划分子网的方式一般是24（网络号）/8（主机号）
            <h2 id="dhcp">DHCP</h2>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议
    <ul>
      <li>动态获取IP就是via这种方式，否则配置静态IP需要子网掩码，DNS服务器地址等</li>
      <li>简单而且IP利用率高</li>
      <li>具体流程：
        <ul>
          <li>发送发现报文 - 想上文的设备在局域网中广播一个DHCP报文，谁会回应就是DHCP服务器
            <ul>
              <li>DHCP服务器可能不止一个</li>
            </ul>
          </li>
          <li>提供报文 -  DHCP寻找一个available的合适IP
            <ul>
              <li>可能有多个DHCP服务器都提供了IP</li>
            </ul>
          </li>
          <li>请求报文 - 想要上文的设备发送请求报文，询问能不能使用某IP
            <ul>
              <li>设备在多个IP中随便选了一个，再询问能不能用</li>
            </ul>
          </li>
          <li>确认报文 - DHCP服务器发送确认
            <ul>
              <li>所有DHCP看看这个IP是不是自己的，更新自己的表</li>
            </ul>
          </li>
          <li>以上报文包含了IP，子网掩码等信息</li>
        </ul>
      </li>
      <li>一些知识
        <ul>
          <li>默认DHCP服务器端口是67</li>
          <li>设备的DHCP请求端口默认是68</li>
          <li>发现报文 IP：0.0.0.0 目的IP：255.255.255.255</li>
          <li>在应用层实现，通过进程实现
            <h2 id="dnsdomain-name-server">DNS(Domain Name Server)</h2>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>域名解析服务器</li>
</ul>

<h2 id="macmedia-access-control">MAC(Media Access Control)</h2>
<ul>
  <li>唯一标识符</li>
  <li>在物理层传输中靠它识别身份</li>
  <li>MAC地址是网卡出厂时设定的
    <ul>
      <li>由组织和厂家分配</li>
    </ul>
  </li>
  <li>IP地址是网络层的地址，而MAC地址是数据链路层的地址</li>
  <li>MAC与IP地址之间的映射由ARP(Address Resolution Protocol)协议完成</li>
</ul>

<h2 id="端口">端口</h2>
<ul>
  <li>全称是协议端口（Protocol Port）可以理解为一个Queue，数据被按照目标端口入队，等待被进程取用</li>
  <li>一台一个IP地址的设备提供多种服务：比如HTTP，FTP，SMTP等</li>
  <li>端口号的范围从0~65536（16比特）</li>
  <li>80 - HTTP； 21 - FTP</li>
  <li>个人理解应该在网络层，给应用程序分配的</li>
</ul>

<h2 id="网关">网关</h2>
<ul>
  <li>是一个网络层的概念,PC把所有的IP包都发送到一个地址上,这个地址(用作中转)在路由器中,用于转发</li>
</ul>

:ET